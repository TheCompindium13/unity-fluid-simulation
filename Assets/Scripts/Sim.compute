#pragma kernel MoveParticles
#pragma kernel ResetCounter
#pragma kernel InsertToBucket
#pragma kernel DebugHash
#pragma kernel PrefixSum1
#pragma kernel PrefixSum2
#pragma kernel PrefixSum3
#pragma kernel Sort
#pragma kernel CalcPressure
#pragma kernel CalcForces
#pragma kernel Step

#define PI 3.1415926535

// 2 is the optimal value, according to my experiment.
// If this value is too small, the number of particles per one grid cell increases. (Inefficient)
// If this value is too large, the number of grid cells to check increases. (Overhead)
// Also note that, unrolling all three loops make the performance worse! (Why?)
#define GRIDS_PER_DIAMETER    2

float3 gridScale;
float3 gridOffset;
uint numHash; // Should be power of two.

struct Particle {
    float4 pos; // with density as w component.
    float4 vel; // with pressure as w component.
};

RWStructuredBuffer<uint> hashes;
RWStructuredBuffer<uint> localIndices;
RWStructuredBuffer<uint> inverseIndices;

uint numParticles;

float radiusSqr;
float radius;
float gasConst;
float restDensity;
float mass;
float viscosity;
float gravity;
float deltaTime;

float3 minBounds;
float3 maxBounds;

float poly6Coeff;
float spikyCoeff;
float viscoCoeff;

uint moveBeginIndex;
uint moveSize;
float3 movePos;
float3 moveVel;

RWStructuredBuffer<Particle> particles;
RWStructuredBuffer<Particle> sorted;

// Double buffered for leapfrog integration.
RWStructuredBuffer<float4> forces;
uint frameNumber;

#define PREFIX_SUM_ARRAY_NAME globalHashCounter

#include "PrefixSum.cginc"

RWStructuredBuffer<uint> hashDebug;

uint3 murmur_32_scramble(uint3 k) {
    k *= 0xcc9e2d51;
    k = (k << 15) | (k >> 17);
    k *= 0x1b873593;
    return k;
}

uint calculateHash(int3 normed) {
    // Murmur3
    // ~27 collision
    uint h = 0; // seed

    uint3 scrambled = murmur_32_scramble(normed);

    h ^= scrambled.x;
    h = (h << 13) | (h >> 19);
    h = h * 5 + 0xe6546b64U;

    h ^= scrambled.y;
    h = (h << 13) | (h >> 19);
    h = h * 5 + 0xe6546b64U;

    h ^= scrambled.z;
    h = (h << 13) | (h >> 19);
    h = h * 5 + 0xe6546b64U;

    // Simple xor
    // ~33 collision
    // uint h = 73856093 * normed.x ^ 19349663 * normed.y ^ 83492791 * normed.z;

    // FNV-1a
    // ~27 collision
    // uint h = 0x811c9dc5U;

    // h = h ^ ((normed.x >> 0) & 255);
    // h = h * 0x01000193;
    // h = h ^ ((normed.x >> 8) & 255);
    // h = h * 0x01000193;
    // h = h ^ ((normed.x >> 16) & 255);
    // h = h * 0x01000193;
    // h = h ^ ((normed.x >> 24) & 255);
    // h = h * 0x01000193;

    // h = h ^ ((normed.y >> 0) & 255);
    // h = h * 0x01000193;
    // h = h ^ ((normed.y >> 8) & 255);
    // h = h * 0x01000193;
    // h = h ^ ((normed.y >> 16) & 255);
    // h = h * 0x01000193;
    // h = h ^ ((normed.y >> 24) & 255);
    // h = h * 0x01000193;

    // h = h ^ ((normed.z >> 0) & 255);
    // h = h * 0x01000193;
    // h = h ^ ((normed.z >> 8) & 255);
    // h = h * 0x01000193;
    // h = h ^ ((normed.z >> 16) & 255);
    // h = h * 0x01000193;
    // h = h ^ ((normed.z >> 24) & 255);
    // h = h * 0x01000193;

    h = h & (numHash-1);
    return h;
}

float poly6(float d) {
    return poly6Coeff * pow(radiusSqr - d, 3);
}

float spiky(float l) {
    return spikyCoeff * pow(radius - l, 2);
}

float visco(float l) {
    return viscoCoeff * (radius - l);
}

#define BEGIN_FOREACH_PARTICLES                                         \
int3 base = floor(GRIDS_PER_DIAMETER/2.0 * (pi.pos.xyz / radius - 1));  \
for (int dx = 0; dx < GRIDS_PER_DIAMETER+1; dx++) {                     \
    for (int dy = 0; dy < GRIDS_PER_DIAMETER+1; dy++) {                 \
        for (int dz = 0; dz < GRIDS_PER_DIAMETER+1; dz++) {             \
            uint h = calculateHash(base + int3(dx, dy, dz));            \
            uint begin = h > 0 ? globalHashCounter[h-1] : 0;            \
            uint end = globalHashCounter[h];                            \
            const uint maxIter = 2048;                                  \
            uint cnt = end - begin;                                     \
            float scaleFactor = max((float)(end - begin) / maxIter, 1); \
            end = min(end, begin + maxIter);                            \
            for (uint i = begin; i < end; i++) {                        \
                Particle pj = sorted[i];                                \
                float3 diff = pi.pos.xyz - pj.pos.xyz;                  \
                float d = dot(diff, diff);                              \
                if (d < radiusSqr) {                                    \


#define END_FOREACH_PARTICLES   }}}}}

[numthreads(1024,1,1)]
void MoveParticles (uint3 id : SV_DispatchThreadID)
{
    uint totalParticlesToMove = moveSize * moveSize;

    const float moveAreaSize = 5.0;

    for (uint x = 0; x < moveSize; x++) {
        for (uint y = 0; y < moveSize; y++) {
            uint idx = (moveBeginIndex + x * moveSize + y) % numParticles;

            particles[idx].pos.xyz = movePos + float3(x, 0, y) / moveSize * moveAreaSize - float3(1, 0, 1) * moveAreaSize * 0.5;
            particles[idx].vel.xyz = moveVel;

            forces[idx] = 0;
            forces[idx + numParticles] = 0;
        }
    }
}

[numthreads(1024,1,1)]
void ResetCounter (uint3 id : SV_DispatchThreadID)
{
    if (id.x < numHash) {
        globalHashCounter[id.x] = 0;
    }
}

[numthreads(1024,1,1)]
void InsertToBucket (uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles) {
        int3 normed = floor(GRIDS_PER_DIAMETER/2.0 * (particles[id.x].pos.xyz / radius));
        uint h = calculateHash(normed);
        hashes[id.x] = h;

        uint localIndex;
        InterlockedAdd(globalHashCounter[h], 1, localIndex);

        localIndices[id.x] = localIndex;
    }
}

[numthreads(1024,1,1)]
void DebugHash (uint3 id : SV_DispatchThreadID)
{
    if (id.x < numHash) {
        if (globalHashCounter[id.x] > 0) {
            InterlockedAdd(hashDebug[0], 1);
            InterlockedMax(hashDebug[1], globalHashCounter[id.x]);
        }
    }
}

[numthreads(1024,1,1)]
void Sort (uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles) {
        uint sortedIndex = 0;
        uint h = hashes[id.x];
        if (h > 0) {
            sortedIndex += globalHashCounter[h-1];
        }
        sortedIndex += localIndices[id.x];

        sorted[sortedIndex] = particles[id.x];

        inverseIndices[sortedIndex] = id.x;
    }
}

[numthreads(1024,1,1)]
void CalcPressure (uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles) {
        Particle pi = sorted[id.x];

        // float density = mass * poly6(0);
        float density = 0;

        BEGIN_FOREACH_PARTICLES
            // if (d > 0) {
                density += mass * poly6(d) * scaleFactor;
            // }
        END_FOREACH_PARTICLES

        sorted[id.x].pos.w = density;
        // Clamp negative pressure. This happens when a particle has a few neighbors.
        sorted[id.x].vel.w = max(gasConst * (density - restDensity), 0);
    }
}

[numthreads(1024,1,1)]
void CalcForces (uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles) {
        Particle pi = sorted[id.x];

        float3 force = 0;

        BEGIN_FOREACH_PARTICLES
            if (d > 0) {
                float l = sqrt(d);
                // Pressure
                force += mass * (pi.vel.w + pj.vel.w) / (2*pj.pos.w) * spiky(l) * normalize(diff) * scaleFactor;
                // Viscosity
                force += viscosity * mass / (pj.pos.w) * visco(l) * (pj.vel - pi.vel).xyz * scaleFactor;
            }
        END_FOREACH_PARTICLES

        // Gravity
        force += mass * gravity * float3(0,-1,0);

        forces[inverseIndices[id.x] + (frameNumber&1) * numParticles].xyz = force;
    }
}

[numthreads(1024,1,1)]
void Step (uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles) {
        Particle pi = sorted[id.x];

        float3 prevAcc = forces[inverseIndices[id.x] + ((~frameNumber)&1) * numParticles].xyz / mass;
        float3 currAcc = forces[inverseIndices[id.x] + (frameNumber&1) * numParticles].xyz / mass;

        pi.pos.xyz += pi.vel.xyz * deltaTime + 0.5 * prevAcc * deltaTime * deltaTime;
        pi.vel.xyz += 0.5 * (prevAcc + currAcc) * deltaTime;

        const float eps = 0.001f;
        const float damping = 0.5f;

        if (pi.pos.x < minBounds.x) {
            pi.pos.x = minBounds.x + eps;
            pi.vel.x = abs(pi.vel.x) * damping;
        }
        if (pi.pos.y < minBounds.y) {
            pi.pos.y = minBounds.y + eps;
            pi.vel.y = abs(pi.vel.y) * damping;
        }
        if (pi.pos.z < minBounds.z) {
            pi.pos.z = minBounds.z + eps;
            pi.vel.z = abs(pi.vel.z) * damping;
        }
        if (pi.pos.x > maxBounds.x) {
            pi.pos.x = maxBounds.x - eps;
            pi.vel.x = -abs(pi.vel.x) * damping;
        }
        if (pi.pos.y > maxBounds.y) {
            pi.pos.y = maxBounds.y - eps;
            pi.vel.y = -abs(pi.vel.y) * damping;
        }
        if (pi.pos.z > maxBounds.z) {
            pi.pos.z = maxBounds.z - eps;
            pi.vel.z = -abs(pi.vel.z) * damping;
        }

        particles[inverseIndices[id.x]] = pi;
    }
}